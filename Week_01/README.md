学习笔记

一、针对移动0的题目

根据题目的要求，采用了三种方法进行实现

方法一，生成一个新数组，与原数组长度相同，循环遍历原数组，将非零元素依次存入新数组中，最后，再循环新数组，将所有元素赋值进原数组中，这里因为数据类型为int，故可以直接赋值，不用单独为了0再进行重新赋值

时间复杂度：O(n)
空间复杂度：O(n)

方法二，快慢指针法，慢指针指向非零元素应当存储的位置，快指针依次遍历数组，当遇到非零元素时，与满指针交换

时间复杂度：O(n)
空间复杂度：O(n)

方法三，循环遍历数组，遇到0，则将后面元素整体往前移动，再往数组末尾添加0，由于时间复杂度较高，可以作为研究尝试，但实际上开发时，应当舍弃

时间复杂度：O(n^3)
空间复杂度：O(n)

二、三数之和中的三重循环方法

三重循环方法中，视频中覃超分析了代码，进行数组排序的部分可以去掉。但是，阅读Arrays.asList()方法源码，并没有针对可变参数进行排序的功能，故如果没有针对数组进行提前排序，会得到重复的三个元素组合

Arrays.asList()源码如下：

public static <T> List<T> asList(T... a) {
	return new ArrayList<>(a);
}

三、散列表设计的关键

散列表设计的关键，在于hash函数，设计好，冲突较少，能够让数值分散均匀，否则，较为集中，导致单链表太多，效率降低。

解决散列表冲突的方法，叫做拉链式解决冲突法

四、接口

对于接口而言，其本身没有具体的代码实现，定义的是一种能力，个人觉得，这样的思想非常好，先把思想统一，具体的实现方式，可以千差万别，但不会跑出核心思想。

